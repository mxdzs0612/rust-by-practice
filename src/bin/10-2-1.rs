// Const æ³›å‹
// åœ¨ä¹‹å‰çš„æ³›å‹ä¸­ï¼Œå¯ä»¥æŠ½è±¡ä¸ºä¸€å¥è¯ï¼šé’ˆå¯¹ç±»å‹å®ç°çš„æ³›å‹ï¼Œæ‰€æœ‰çš„æ³›å‹éƒ½æ˜¯ä¸ºäº†æŠ½è±¡ä¸åŒçš„ç±»å‹ï¼Œé‚£æœ‰æ²¡æœ‰é’ˆå¯¹å€¼çš„æ³›å‹ï¼Ÿç­”æ¡ˆå°±æ˜¯ Const æ³›å‹ã€‚
// ğŸŒŸğŸŒŸ <T, const N: usize> æ˜¯ç»“æ„ä½“ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œå’Œæ•°ç»„ç±»å‹ä¸€æ ·ï¼Œè¿™æ„å‘³ç€é•¿åº¦ä¸åŒä¼šå¯¼è‡´ç±»å‹ä¸åŒï¼š Array<i32, 3> å’Œ Array<i32, 4> æ˜¯ä¸åŒçš„ç±»å‹

// ä¸‹é¢çš„ä¾‹å­åŒæ—¶ä½¿ç”¨æ³›å‹å’Œ const æ³›å‹æ¥å®ç°ä¸€ä¸ªç»“æ„ä½“ï¼Œè¯¥ç»“æ„ä½“çš„å­—æ®µä¸­çš„æ•°ç»„é•¿åº¦æ˜¯å¯å˜çš„

// struct ArrayPair<T, const N: usize> {
//     left: [T; N],
//     right: [T; N],
// }

// impl<T: Debug, const N: usize> Debug for ArrayPair<T, N> {
//     // ...
// }

// ç›®å‰ï¼Œconst æ³›å‹å‚æ•°åªèƒ½ä½¿ç”¨ä»¥ä¸‹å½¢å¼çš„å®å‚:
// ä¸€ä¸ªå•ç‹¬çš„ const æ³›å‹å‚æ•°
// ä¸€ä¸ªå­—é¢é‡ (i.e. æ•´æ•°, å¸ƒå°”å€¼æˆ–å­—ç¬¦).
// ä¸€ä¸ªå…·ä½“çš„ const è¡¨è¾¾å¼( è¡¨è¾¾å¼ä¸­ä¸èƒ½åŒ…å«ä»»ä½• æ³›å‹å‚æ•°)

// fn foo<const N: usize>() {}

// fn bar<T, const M: usize>() {
//     foo::<M>(); // ok: ç¬¦åˆç¬¬ä¸€ç§
//     foo::<2021>(); // ok: ç¬¦åˆç¬¬äºŒç§
//     foo::<{20 * 100 + 20 * 10 + 1}>(); // ok: ç¬¦åˆç¬¬ä¸‰ç§
    
//     foo::<{ M + 1 }>(); // error: è¿èƒŒç¬¬ä¸‰ç§ï¼Œconst è¡¨è¾¾å¼ä¸­ä¸èƒ½æœ‰æ³›å‹å‚æ•° M
//     foo::<{ std::mem::size_of::<T>() }>(); // error: æ³›å‹è¡¨è¾¾å¼åŒ…å«äº†æ³›å‹å‚æ•° T
    
//     let _: [u8; M]; // ok: ç¬¦åˆç¬¬ä¸€ç§
//     let _: [u8; std::mem::size_of::<T>()]; // error: æ³›å‹è¡¨è¾¾å¼åŒ…å«äº†æ³›å‹å‚æ•° T
// }

// fn main() {}

// const æ³›å‹è¿˜èƒ½å¸®æˆ‘ä»¬é¿å…ä¸€äº›è¿è¡Œæ—¶æ£€æŸ¥ï¼Œæå‡æ€§èƒ½

// pub struct MinSlice<T, const N: usize> {
//     pub head: [T; N],
//     pub tail: [T],
// }

// fn main() {
//     let slice: &[u8] = b"Hello, world";
//     let reference: Option<&u8> = slice.get(6);
//     // æˆ‘ä»¬çŸ¥é“ `.get` è¿”å›çš„æ˜¯ `Some(b' ')`
//     // ä½†ç¼–è¯‘å™¨ä¸çŸ¥é“
//     assert!(reference.is_some());

//     let slice: &[u8] = b"Hello, world";

//     // å½“ç¼–è¯‘æ„å»º MinSlice æ—¶ä¼šè¿›è¡Œé•¿åº¦æ£€æŸ¥ï¼Œä¹Ÿå°±æ˜¯åœ¨ç¼–è¯‘æœŸæˆ‘ä»¬å°±çŸ¥é“å®ƒçš„é•¿åº¦æ˜¯ 12
//     // åœ¨è¿è¡ŒæœŸï¼Œä¸€æ—¦ `unwrap` æˆåŠŸï¼Œåœ¨ `MinSlice` çš„ä½œç”¨åŸŸå†…ï¼Œå°±å†æ— éœ€ä»»ä½•æ£€æŸ¥    
//     let minslice = MinSlice::<u8, 12>::from_slice(slice).unwrap();
//     let value: u8 = minslice.head[6];
//     assert_eq!(value, b' ')
// }

// // ä¿®å¤é”™è¯¯
// struct Array<T, const N: usize> {
//     data : [T; N]
// }

// fn main() {
//     let arrays = [
//         Array{
//             data: [1, 2, 3],
//         },
//         Array {
//             data: [1.0, 2.0, 3.0],
//         },
//         Array {
//             data: [1, 2]
//         }
//     ];
// }


// ä¿®å¤é”™è¯¯
struct Array<T, const N: usize> {
    data : [T; N]
}

fn main() {
    let arrays = [
        Array{
            data: [1, 2, 3],
        },
        Array {
            data: [1, 2, 3],
        },
        Array {
            data: [1, 2, 0]
        }
    ];
}